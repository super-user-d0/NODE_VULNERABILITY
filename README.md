
##  üö® üö® Vulnerability spotted in most Node.js servers  üö® üö®

This page discusses an existing, "vivid" problem that can put almost all 
Node.js servers relying on external libraries at risk.

I tried my best to be as brief as possible so as not to waste your time if 
you are reading this page.

### Special Note
Based on my research, this vulnerability is not only tied to Node.js but to any 
other language such as Python, Ruby, Go, Java, etc. However, for simplicity, 
i will focus on Node.js throughout this page.


### The Issue
#### 1
When you call an external package, whether it's a library or framework, behind the scenes 
(BTS), you are essentially calling a function from another file. This means, like any 
other function, the external module has full access to the running process.

What I'm trying to say is this: everyone uses environmental variables to store application 
secrets, which I also believed was 100% secure. But consider this scenario: what if an 
external package or library called within the program ran
```javascript 
console.log(process.env);
```
Since the external package runs in the same process as your program, it obviously shares 
the same environment variables. This grants the library full permission to view and modify 
environmental variables.

#### 2
If the library is intended to be used as a middleware for Node.js servers or Express 
applications, you are handing over the entire client request to the middleware function 
when you attach it to a request.

So imagine the developer did this in the library's codebase
``` javascript
export default function validateInformation(request, response, nextMiddleware) {
  // ...handle validation 
  const { body, headers, url } = request; 
  // store in a file or transfer to a remote server etc.
  nextMiddleware();
}
```
With just a single line of code, one can already gain access to the request headers 
(your access token might be there, possibly in the Authorization header), the request 
URL to identify the kind of request, and the request body/payload: your logins might be 
there ü§∑‚Äç‚ôÇÔ∏è.
```json
{
  "email": "super-user-d0",
  "password": "d0What??"
}
```

#### 3
You might be feeling, "LOL, it's proprietary software; you barely know the ins and outs," 
but not when the attacker runs a function that copies your entire codebase and sends it 
to a remote server.


### Example
In this repository, you can see that I created a basic example demonstrating my 
explanation. Feel free to clone this repo and run the servers I set up to demonstrate my 
point. If you look at the filesystem of this repo, you‚Äôll see it has three folders:
```
 malicious-lib/
 remote-server/
 target-server/
```
These folders contains codes demonstrating these attacks.

#### target-server
The /target-server in our example would act as our very own codebase; in this example, 
it's a social media application.

In this directory, we have a dummy .env file and a /src directory containing 2 HTML files 
and an index.js file.

The index.js file contains a very basic server using Express.js, which utilizes 2 
middlewares:

- A middleware that processes the request body and stores it in the request.body property.
- A middleware that handles Cross-Origin Resource Sharing (CORS). In our example, 
this middleware is the one containing the malicious code.

If you have cloned this repository, you can navigate to the target-server 
folder and run npm start.


#### malicious-lib
The `/malicious-lib` in our example would act as the codebase of the CORS library 
containing the malicious code.

In this directory, we have a /src directory containing 2 files: index.js and .next.js.

The index.js file is a simple file that handles basic CORS before calling the `NEXT` 
function located in .next.js and passing the request object to it.

The `.next.js` file creates an object with the following information 
```javascript
  const payload = {
    body: request.body, // the request body
    env_var:  process.env, // the application's environmental variable
    headers: request.headers, // the request headers
    method: request.method, // the request method eg: GET, PUT, POST, DELETE etc
    url: request.path // the request url: eg /login
  }
```
And silently sends it to a remote server without logging anything to the standard output 
(terminal). In our example, the endpoint for the remote server is http://localhost:8081, 
assuming you are running it locally.



#### remote-server
The `/remote-server` contains a single JavaScript file that acts as the remote server. 
You can simply run `node index.mjs` to start the server. Please do this before starting 
the target server. When the malicious library receives a request, extracts the necessary 
information, and sends it directly to the remote server, it will be logged to your 
terminal immediately.

**Altogether, the directories in this repository contain a basic example of how an attacker might try to steal information from your server.**


### Common Misinterpretations

- Some people care less about the security of their servers, they typically believe that 
hosting on cloud providers automatically makes it secure. Most cloud providers do not 
expose your insecure HTTP servers to the internet directly. Instead, they set up a reverse 
proxy that securely handles requests using software like Nginx or Apache, etc. However, 
in cases like my example where the vulnerability is already internally 'hidden in the mist,' 
you are on your own.

- HTTPS only helps secure data transmission, it does not encrypt the request to the 
internal layer. Therefore, the request payload is already decrypted by the time you can 
process it.

- Someone might have tried this method and has been using your OpenAI key to find out 
"how to center a div", so no one is overcharging you.

- TypeScript won't make your server secure. It's just JavaScript with type checking, 
so the security TypeScript addresses is "type safety" and not application safety in 
general.

- Frameworks, especially "Node frameworks for building fast servers", only simplify 
development and have little to no impact on security.


### Solution
- I will suggest that npm take additional security measures and screen codebases before 
they are published to the registry. There are too many useless libraries. If only npm 
knew that just one malicious package could potentially destroy the entire npm registry. 
Imagine a library that depends on 7 libraries, where one of these libraries depends on 
12 others, and one of those libraries depends on yet another library containing malicious 
code ü§¶.

- I'll just advise everyone to try minimizing the use of external libraries and, as much 
as possible, to read the codebase of the libraries they are utilizing. Good luck trying 
to read the codebase of BlessedJS, which contains about 16k lines of code, 
according to them.

- It's high time everyone starts writing in modern JavaScript, as CommonJS (cjs) 
codebases should be considered legacy codebases by now.

- Languages should only provide a method for retrieving a single environmental variable 
by its name.

Note that all the above solutions does not guarantee a 100% solution to this vulnerability.


### Contact Info
I've left out my info below. If anyone wants to talk to me about something, tell me why 
this vulnerability is obsolete, or know why my explanation sucks, do contact me.

- name: David.A
- x: super_user_d0
- email: david40au40@gmail.com